<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NEAT Stickman Jetpack Simulator</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/neataptic/1.4.7/neataptic.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;600&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0f; color: #c8f0ff; font-family: 'Share Tech Mono', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
  #header { padding: 5px 16px; border-bottom: 1px solid #1a3a4a; display: flex; align-items: center; gap: 24px; background: #0d0d18; flex-shrink: 0; }
  #header h1 { font-family: 'Rajdhani', sans-serif; font-weight: 600; font-size: 0.95rem; letter-spacing: 4px; color: #00e5ff; text-shadow: 0 0 20px #00e5ff88; }
  .stat { display: flex; flex-direction: column; gap: 1px; }
  .stat-label { font-size: 0.5rem; color: #456; letter-spacing: 2px; text-transform: uppercase; }
  .stat-value { font-size: 0.85rem; color: #00e5ff; }
  #grid { flex: 1; display: grid; grid-template-columns: repeat(6, 1fr); grid-template-rows: repeat(4, 1fr); gap: 2px; background: #111; }
  .sim-wrap { position: relative; overflow: hidden; }
  .sim-wrap canvas { display: block; width: 100%; height: 100%; }
  .sim-label { position: absolute; top: 3px; left: 4px; font-size: 0.42rem; letter-spacing: 1px; opacity: 0.7; pointer-events: none; }
  .sim-stats { position: absolute; top: 3px; right: 4px; font-size: 0.42rem; text-align: right; opacity: 0.8; pointer-events: none; line-height: 1.4; }
  #controls { position: fixed; bottom: 12px; right: 14px; display: flex; gap: 8px; z-index: 10; align-items: center; }
  button { background: #0d1a25; border: 1px solid #00e5ff44; color: #00e5ff; font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; padding: 5px 12px; cursor: pointer; letter-spacing: 1px; }
  button:hover { background: #00e5ff22; border-color: #00e5ff; }
  #hint { position: fixed; bottom: 14px; left: 14px; font-size: 0.6rem; color: #345; letter-spacing: 2px; z-index: 10; }
</style>
</head>
<body>
<div id="header">
  <h1>NEAT // STICKMAN JETPACK ×24</h1>
  <div class="stat"><span class="stat-label">Speed</span><span class="stat-value" id="spd">1x</span></div>
</div>
<div id="grid"></div>
<div id="hint">[ R ] reset all</div>
<div id="controls">
  <label style="color:#00e5ff;font-size:0.7rem;letter-spacing:1px;">SPEED
    <input type="range" id="speedSlider" min="1" max="16" value="1" step="1"
      style="width:100px;margin:0 8px;accent-color:#00e5ff;vertical-align:middle;"
      oninput="updateSpeed(this.value)">
    <span id="spd2" style="min-width:30px;display:inline-block;">1x</span>
  </label>
  <button onclick="resetAll()">↻ RESET</button>
</div>

<script>
var Neat    = neataptic.Neat;
var methods = neataptic.methods;

var NUM_SIMS   = 24;
var POP_SIZE   = 20;
var STEP_LIMIT = 1000;

var THIGH     = 22;
var SHIN      = 20;
var FOOT      = 12;
var TORSO     = 30;
var HEAD_R    = 7;
var UPPER_ARM = 14;
var FOREARM   = 12;
var HAND      = 8;

var GRAVITY       = 0.30;
var FORCE_SCALE   = 0.16;
var DAMPING_AIR   = 0.992;
var DAMPING_GND   = 0.92;
var MAX_TORQUE    = 0.06;
var JOINT_SPRING  = 0.011;
var MAX_JOINT_VEL = 0.18;
var MAX_THRUST    = 0.55;

var HIP_MIN   = -0.9;   var HIP_MAX   = 1.4;
var KNEE_MIN  =  0.0;   var KNEE_MAX  = 1.8;
var ANKLE_MIN = -0.6;   var ANKLE_MAX = 0.8;
var ELBOW_MIN = -1.8;   var ELBOW_MAX = 0.6;
var WRIST_MIN = -0.8;   var WRIST_MAX = 0.8;

var SIM_COLORS = [
  '#00e5ff','#ff9900','#cc44ff','#00ff88','#ff4488','#ffee00',
  '#00ccff','#ff6600','#88ff00','#ff00cc','#00ffcc','#ff3300',
  '#44aaff','#ffaa00','#aa44ff','#00ffaa','#ff44aa','#aaff00',
  '#00aaff','#ff6644','#66ff88','#ff0088','#00ffee','#ff4400'
];
var SIM_NAMES = 'ABCDEFGHIJKLMNOPQRSTUVWX'.split('');

var grid = document.getElementById('grid');
var fragment = document.createDocumentFragment();
for (var i = 0; i < NUM_SIMS; i++) {
  var wrap = document.createElement('div');
  wrap.className = 'sim-wrap';
  wrap.id = 'wrap'+i;
  wrap.innerHTML =
    '<canvas id="c'+i+'"></canvas>' +
    '<div class="sim-label" style="color:'+SIM_COLORS[i]+'">■ SIM '+SIM_NAMES[i]+'</div>' +
    '<div class="sim-stats" id="stats'+i+'"></div>';
  fragment.appendChild(wrap);
}
grid.appendChild(fragment);

function Stickman(brain, sim) {
  this.brain = brain;
  this.sim   = sim;
  this.prevHvx = 0;
  this.lastThrustX = 0;
  this.lastThrustY = 0;
  this.reset();
}

Stickman.prototype.reset = function() {
  var s = this.sim;
  var GY = s.GY;
  this.alive   = true;
  this.fitness = 0;
  this.maxX    = s.STARTX;
  this.phase   = 0;
  this.prevHvx = 0;
  this.airTicks = 0;

  this.hx  = s.STARTX + (Math.random()-0.5)*10;
  this.hy  = GY - SHIN - THIGH - FOOT/2 - 15;
  this.hvx = (Math.random()-0.5)*0.4;
  this.hvy = 0;

  this.lHip   =  0.08;  this.lHipV   = 0;
  this.lKne   =  0.24;  this.lKneV   = 0;
  this.lAnkle =  0.00;  this.lAnkleV = 0;
  this.rHip   = -0.08;  this.rHipV   = 0;
  this.rKne   =  0.24;  this.rKneV   = 0;
  this.rAnkle =  0.00;  this.rAnkleV = 0;

  this.lElb   = -0.8;   this.lElbV   = 0;
  this.lWrist = -0.35;  this.lWristV = 0;
  this.rElb   = -0.8;   this.rElbV   = 0;
  this.rWrist = -0.35;  this.rWristV = 0;

  this.torsoLean  = 0;
  this.torsoLeanV = 0;
  this.lastThrustX = 0;
  this.lastThrustY = 0;
};

Stickman.prototype.fk = function() {
  var hx = this.hx, hy = this.hy;
  var tiltX = Math.sin(this.torsoLean) * 10;
  var tiltY = Math.cos(this.torsoLean) * 5 - 5;
  var sx = hx + tiltX;
  var sy = hy - TORSO + tiltY;

  var hd = { x: sx, y: sy - HEAD_R * 2.2 };

  var lkx = hx - Math.sin(this.lHip) * THIGH;
  var lky = hy + Math.cos(this.lHip) * THIGH;
  var lSA = this.lHip + this.lKne;
  var lax = lkx - Math.sin(lSA) * SHIN;
  var lay = lky + Math.cos(lSA) * SHIN;
  var lFA = lSA + this.lAnkle;
  var lfx = lax - Math.sin(lFA) * FOOT;
  var lfy = lay + Math.cos(lFA) * FOOT;

  var rkx = hx - Math.sin(this.rHip) * THIGH;
  var rky = hy + Math.cos(this.rHip) * THIGH;
  var rSA = this.rHip + this.rKne;
  var rax = rkx - Math.sin(rSA) * SHIN;
  var ray = rky + Math.cos(rSA) * SHIN;
  var rFA = rSA + this.rAnkle;
  var rfx = rax - Math.sin(rFA) * FOOT;
  var rfy = ray + Math.cos(rFA) * FOOT;

  var lShouldAng = -0.6 + Math.sin(this.phase * 0.09) * 0.28;
  var lEx = sx - Math.sin(lShouldAng) * UPPER_ARM;
  var lEy = sy + Math.cos(lShouldAng) * UPPER_ARM;
  var lElbAng = lShouldAng + this.lElb;
  var lWx = lEx - Math.sin(lElbAng) * FOREARM;
  var lWy = lEy + Math.cos(lElbAng) * FOREARM;
  var lWristAng = lElbAng + this.lWrist;
  var lHx = lWx - Math.sin(lWristAng) * HAND;
  var lHy = lWy + Math.cos(lWristAng) * HAND;

  var rShouldAng = 0.6 - Math.sin(this.phase * 0.09) * 0.28;
  var rEx = sx - Math.sin(rShouldAng) * UPPER_ARM;
  var rEy = sy + Math.cos(rShouldAng) * UPPER_ARM;
  var rElbAng = rShouldAng + this.rElb;
  var rWx = rEx - Math.sin(rElbAng) * FOREARM;
  var rWy = rEy + Math.cos(rElbAng) * FOREARM;
  var rWristAng = rElbAng + this.rWrist;
  var rHx = rWx - Math.sin(rWristAng) * HAND;
  var rHy = rWy + Math.cos(rWristAng) * HAND;

  return {
    hip:      { x:hx, y:hy },
    shoulder: { x:sx, y:sy },
    head:     hd,
    lKnee:    { x:lkx, y:lky },
    lAnkle:   { x:lax, y:lay },
    lFoot:    { x:lfx, y:lfy },
    rKnee:    { x:rkx, y:rky },
    rAnkle:   { x:rax, y:ray },
    rFoot:    { x:rfx, y:rfy },
    lElbow:   { x:lEx, y:lEy },
    lWrist:   { x:lWx, y:lWy },
    lHand:    { x:lHx, y:lHy },
    rElbow:   { x:rEx, y:rEy },
    rWrist:   { x:rWx, y:rWy },
    rHand:    { x:rHx, y:rHy },
  };
};

Stickman.prototype.step = function() {
  if (!this.alive) return;
  this.phase++;
  var s  = this.sim;
  var GY = s.GY;
  var topBound = 16;

  var p = this.fk();
  var lFootOnGnd = p.lFoot.y >= GY - 1.5;
  var rFootOnGnd = p.rFoot.y >= GY - 1.5;
  if (!lFootOnGnd && !rFootOnGnd) this.airTicks++;

  var targetY = GY - 120;
  var inputs = [
    (this.hx - s.STARTX) / Math.max(120, s.W * 0.6),
    (this.hy - targetY) / 100,
    this.hvx / 8,
    this.hvy / 8,
    this.torsoLean / 0.8,
    this.lHip / Math.PI, this.lKne / Math.PI, this.lAnkle / Math.PI,
    this.rHip / Math.PI, this.rKne / Math.PI, this.rAnkle / Math.PI,
    this.lElb / Math.PI, this.rElb / Math.PI,
    lFootOnGnd ? 1 : 0,
    rFootOnGnd ? 1 : 0,
    Math.sin(this.phase * 0.04),
  ];

  var out = this.brain.activate(inputs);

  var lHT = (out[0] - 0.5) * 2 * MAX_TORQUE;
  var lKT = (out[1] - 0.5) * 2 * MAX_TORQUE;
  var lAT = (out[2] - 0.5) * 2 * MAX_TORQUE * 0.6;
  var lET = (out[3] - 0.5) * 2 * MAX_TORQUE * 0.8;

  var rHT = (out[4] - 0.5) * 2 * MAX_TORQUE;
  var rKT = (out[5] - 0.5) * 2 * MAX_TORQUE;
  var rAT = (out[6] - 0.5) * 2 * MAX_TORQUE * 0.6;
  var rET = (out[7] - 0.5) * 2 * MAX_TORQUE * 0.8;

  var thrustX = (out[8] - 0.5) * 2 * MAX_THRUST;
  var thrustY = Math.max(0, out[9]) * MAX_THRUST * 1.4;
  var stabilize = (out[10] - 0.5) * 2;

  var torqueSum = Math.abs(lHT)+Math.abs(lKT)+Math.abs(lAT)+Math.abs(lET)+
                  Math.abs(rHT)+Math.abs(rKT)+Math.abs(rAT)+Math.abs(rET)+
                  Math.abs(thrustX)+Math.abs(thrustY);

  this.lHipV   += lHT + ( 0.08 - this.lHip)   * JOINT_SPRING;
  this.lKneV   += lKT + ( 0.24 - this.lKne)   * JOINT_SPRING;
  this.lAnkleV += lAT + ( 0.00 - this.lAnkle) * JOINT_SPRING;
  this.lElbV   += lET + (-0.80 - this.lElb)   * JOINT_SPRING * 0.7;

  this.rHipV   += rHT + (-0.08 - this.rHip)   * JOINT_SPRING;
  this.rKneV   += rKT + ( 0.24 - this.rKne)   * JOINT_SPRING;
  this.rAnkleV += rAT + ( 0.00 - this.rAnkle) * JOINT_SPRING;
  this.rElbV   += rET + (-0.80 - this.rElb)   * JOINT_SPRING * 0.7;

  var armReaction = -(lET + rET) * 0.16;
  var jetpackReaction = (-thrustX * 0.12) + (stabilize * -this.torsoLean * 0.06);
  this.torsoLeanV += armReaction + jetpackReaction;
  this.torsoLeanV *= 0.93;
  this.torsoLean += this.torsoLeanV;
  this.torsoLean = Math.max(-0.9, Math.min(0.9, this.torsoLean));

  this.lHipV   *= DAMPING_AIR; this.lKneV   *= DAMPING_AIR; this.lAnkleV *= DAMPING_AIR; this.lElbV   *= DAMPING_AIR;
  this.rHipV   *= DAMPING_AIR; this.rKneV   *= DAMPING_AIR; this.rAnkleV *= DAMPING_AIR; this.rElbV   *= DAMPING_AIR;
  this.torsoLeanV *= DAMPING_AIR;

  this.lHipV   = Math.max(-MAX_JOINT_VEL, Math.min(MAX_JOINT_VEL, this.lHipV));
  this.lKneV   = Math.max(-MAX_JOINT_VEL, Math.min(MAX_JOINT_VEL, this.lKneV));
  this.lAnkleV = Math.max(-MAX_JOINT_VEL*0.7, Math.min(MAX_JOINT_VEL*0.7, this.lAnkleV));
  this.lElbV   = Math.max(-MAX_JOINT_VEL*0.8, Math.min(MAX_JOINT_VEL*0.8, this.lElbV));
  this.rHipV   = Math.max(-MAX_JOINT_VEL, Math.min(MAX_JOINT_VEL, this.rHipV));
  this.rKneV   = Math.max(-MAX_JOINT_VEL, Math.min(MAX_JOINT_VEL, this.rKneV));
  this.rAnkleV = Math.max(-MAX_JOINT_VEL*0.7, Math.min(MAX_JOINT_VEL*0.7, this.rAnkleV));
  this.rElbV   = Math.max(-MAX_JOINT_VEL*0.8, Math.min(MAX_JOINT_VEL*0.8, this.rElbV));

  this.lHip   += this.lHipV;   this.lKne   += this.lKneV;   this.lAnkle += this.lAnkleV;   this.lElb   += this.lElbV;
  this.rHip   += this.rHipV;   this.rKne   += this.rKneV;   this.rAnkle += this.rAnkleV;   this.rElb   += this.rElbV;

  this.lHip   = Math.max(HIP_MIN,   Math.min(HIP_MAX,   this.lHip));
  this.rHip   = Math.max(HIP_MIN,   Math.min(HIP_MAX,   this.rHip));
  this.lKne   = Math.max(KNEE_MIN,  Math.min(KNEE_MAX,  this.lKne));
  this.rKne   = Math.max(KNEE_MIN,  Math.min(KNEE_MAX,  this.rKne));
  this.lAnkle = Math.max(ANKLE_MIN, Math.min(ANKLE_MAX, this.lAnkle));
  this.rAnkle = Math.max(ANKLE_MIN, Math.min(ANKLE_MAX, this.rAnkle));
  this.lElb   = Math.max(ELBOW_MIN, Math.min(ELBOW_MAX, this.lElb));
  this.rElb   = Math.max(ELBOW_MIN, Math.min(ELBOW_MAX, this.rElb));

  this.hvy += GRAVITY * FORCE_SCALE;
  this.hvx += thrustX * FORCE_SCALE * 2.5;
  this.hvy -= thrustY * FORCE_SCALE * 2.5;
  this.lastThrustX = thrustX;
  this.lastThrustY = thrustY;

  this.hvx *= DAMPING_AIR;
  this.hvy *= DAMPING_AIR;

  this.hx += this.hvx;
  this.hy += this.hvy;

  var p2 = this.fk();
  var hardLandingPenalty = 0;
  if (p2.lFoot.y > GY || p2.rFoot.y > GY) {
    var penetration = Math.max(0, p2.lFoot.y - GY, p2.rFoot.y - GY);
    this.hy -= penetration;
    hardLandingPenalty = Math.max(0, this.hvy) * 30;
    this.hvy *= -0.18;
    this.hvx *= DAMPING_GND;
  }

  if (this.hy < topBound) {
    this.hy = topBound;
    if (this.hvy < 0) this.hvy *= -0.2;
  }

  if (this.hx > this.maxX) this.maxX = this.hx;

  var progress = Math.max(0, this.maxX - s.STARTX);
  var altitudeBonus = Math.max(0, (GY - this.hy - 40) / 90) * 120;
  var hoverStability = Math.max(0, 1 - Math.abs((this.hy - targetY) / 95)) * 85;
  var airtimeBonus = this.airTicks * 0.22;
  var velocityBonus = Math.max(0, this.hvx) * 30;
  var smoothnessPenalty = Math.abs(this.hvx - this.prevHvx) * 8;
  var energyPenalty = torqueSum * 0.9;
  this.prevHvx = this.hvx;

  this.fitness = progress * 1.35 + altitudeBonus + hoverStability + airtimeBonus + velocityBonus - energyPenalty - smoothnessPenalty - hardLandingPenalty;

  if (p2.head.y + HEAD_R > GY + 3 || p2.shoulder.y > GY) this.alive = false;
  if (this.hy > GY + 20) this.alive = false;
};

Stickman.prototype.draw = function(ctx, isChamp, baseColor) {
  var p = this.fk();

  let drawColor, drawColor2, lineWidth;

  if (isChamp) {
    drawColor  = baseColor;
    drawColor2 = baseColor + '88';
    lineWidth  = 2.5;
  } else {
    drawColor  = baseColor + '55';
    drawColor2 = baseColor + '28';
    lineWidth  = 1.4;
  }

  ctx.save();
  ctx.globalAlpha = isChamp ? 1.0 : 0.45;
  ctx.lineCap = 'round'; ctx.lineJoin = 'round';

  if (isChamp) {
    ctx.shadowColor = baseColor;
    ctx.shadowBlur  = 10;
  }

  function seg(a, b, c) {
    ctx.strokeStyle = c || drawColor;
    ctx.lineWidth = lineWidth;
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
  }

  seg(p.hip,      p.rKnee,  drawColor2);
  seg(p.rKnee,    p.rAnkle, drawColor2);
  seg(p.rAnkle,   p.rFoot,  drawColor2);
  seg(p.shoulder, p.rElbow, drawColor2);
  seg(p.rElbow,   p.rWrist, drawColor2);
  seg(p.rWrist,   p.rHand,  drawColor2);

  seg(p.hip,      p.shoulder);
  seg(p.hip,      p.lKnee);
  seg(p.lKnee,    p.lAnkle);
  seg(p.lAnkle,   p.lFoot);
  seg(p.shoulder, p.lElbow);
  seg(p.lElbow,   p.lWrist);
  seg(p.lWrist,   p.lHand);

  ctx.strokeStyle = drawColor;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  ctx.arc(p.head.x, p.head.y, HEAD_R, 0, Math.PI*2);
  ctx.stroke();

  var flamePower = Math.max(0, this.lastThrustY * 1.2 + Math.abs(this.lastThrustX) * 0.6);
  if (flamePower > 0.02) {
    var fx = p.shoulder.x - Math.sin(this.torsoLean) * 8;
    var fy = p.shoulder.y + Math.cos(this.torsoLean) * 8;
    var flameLen = 6 + flamePower * 20;
    ctx.lineWidth = isChamp ? 2 : 1.2;
    ctx.strokeStyle = 'rgba(255,180,70,' + (isChamp ? 0.9 : 0.4) + ')';
    ctx.beginPath();
    ctx.moveTo(fx, fy);
    ctx.lineTo(fx - this.lastThrustX * 16 + Math.sin(this.torsoLean) * flameLen, fy + Math.cos(this.torsoLean) * flameLen);
    ctx.stroke();
  }

  ctx.restore();
};

function Simulation(idx) {
  this.idx    = idx;
  this.color  = SIM_COLORS[idx];
  this.canvas = document.getElementById('c'+idx);
  this.ctx    = this.canvas.getContext('2d');
  this.W = this.H = this.GY = this.STARTX = this.camX = 0;
  this.generation = 0; this.simStep = 0; this.bestEver = -999999;
  this.stickmen = []; this.neat = null;
  this.resize();
}

Simulation.prototype.resize = function() {
  var wrap = this.canvas.parentElement;
  this.W = this.canvas.width  = wrap.offsetWidth;
  this.H = this.canvas.height = wrap.offsetHeight;
  this.GY     = Math.floor(this.H * 0.82);
  this.STARTX = Math.floor(this.W * 0.35);
};

Simulation.prototype.init = function() {
  this.neat = new Neat(16, 11, null, {
    mutation: [
      methods.mutation.ADD_NODE, methods.mutation.ADD_CONN,
      methods.mutation.MOD_WEIGHT, methods.mutation.MOD_BIAS,
      methods.mutation.MOD_ACTIVATION,
      methods.mutation.SUB_CONN, methods.mutation.SUB_NODE,
    ],
    popsize:        POP_SIZE,
    mutationRate:   0.22,
    mutationAmount: 12,
    elitism:        5,
  });
  this.generation = 0; this.bestEver = -999999;
  this.camX = this.STARTX - this.W * 0.5;
  this.spawnGeneration();
};

Simulation.prototype.spawnGeneration = function() {
  this.generation++; this.simStep = 0;
  this.stickmen = this.neat.population.map(g => new Stickman(g, this));
};

Simulation.prototype.evolve = function() {
  for (var i = 0; i < this.neat.population.length; i++)
    this.neat.population[i].score = this.stickmen[i] ? this.stickmen[i].fitness : 0;

  this.bestEver = Math.max.apply(null, [this.bestEver].concat(
    this.stickmen.map(s => s ? s.fitness : -999999)
  ));

  this.neat.sort();
  this.neat.evolve();
  this.spawnGeneration();
};

Simulation.prototype.getChamp = function() {
  var best = this.stickmen[0];
  for (var i = 1; i < this.stickmen.length; i++)
    if (this.stickmen[i] && this.stickmen[i].fitness >= best.fitness) best = this.stickmen[i];
  return best;
};

Simulation.prototype.update = function() {
  var alive = 0;
  for (var i = 0; i < this.stickmen.length; i++) {
    this.stickmen[i].step();
    if (this.stickmen[i].alive) alive++;
  }
  this.simStep++;
  if (this.simStep >= STEP_LIMIT || alive < POP_SIZE * 0.2) this.evolve();
};

Simulation.prototype.draw = function() {
  var ctx = this.ctx, W = this.W, H = this.H, GY = this.GY;
  ctx.clearRect(0, 0, W, H);

  var bg = ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,'#060610'); bg.addColorStop(1,'#08121e');
  ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);

  var champ = this.getChamp();
  this.camX = champ.hx - W * 0.35;

  ctx.save();
  ctx.translate(-this.camX, 0);

  ctx.strokeStyle = '#0c1820'; ctx.lineWidth = 1;
  var gx0 = Math.floor(this.camX/50)*50;
  for (var gx = gx0; gx < this.camX+W+50; gx += 50) {
    ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,H); ctx.stroke();
  }
  for (var gy2 = 0; gy2 < H; gy2 += 50) {
    ctx.beginPath(); ctx.moveTo(this.camX,gy2); ctx.lineTo(this.camX+W,gy2); ctx.stroke();
  }

  var gr = ctx.createLinearGradient(0,GY,0,H);
  gr.addColorStop(0,'#123247'); gr.addColorStop(1,'#05101a');
  ctx.fillStyle = gr; ctx.fillRect(this.camX, GY, this.camX + W*5, H-GY);
  ctx.strokeStyle = this.color+'55'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(this.camX,GY); ctx.lineTo(this.camX+W*5,GY); ctx.stroke();

  ctx.strokeStyle = '#4aa7ff26'; ctx.lineWidth = 1;
  for (var ay = 40; ay < GY; ay += 55) {
    ctx.beginPath();
    ctx.moveTo(this.camX, ay);
    ctx.lineTo(this.camX + W*2.5, ay);
    ctx.stroke();
  }

  for (var i = 0; i < this.stickmen.length; i++)
    if (this.stickmen[i] !== champ)
      this.stickmen[i].draw(ctx, false, this.color);

  champ.draw(ctx, true, this.color);

  ctx.restore();

  ctx.fillStyle = '#0d1a25'; ctx.fillRect(0, H-3, W, 3);
  var normalized = Math.max(0, (champ.fitness + 600) / 2000);
  var barW = Math.min(W, normalized * W);
  ctx.fillStyle = this.color+'aa'; ctx.fillRect(0, H-3, barW, 3);

  var aliveCnt = 0, bestFit = -999999;
  for (var i = 0; i < this.stickmen.length; i++) {
    if (this.stickmen[i] && this.stickmen[i].alive) aliveCnt++;
    if (this.stickmen[i] && this.stickmen[i].fitness > bestFit) bestFit = this.stickmen[i].fitness;
  }

  document.getElementById('stats'+this.idx).innerHTML =
    '<span style="color:'+this.color+'">GEN '+this.generation+'</span><br>' +
    'ALIVE '+aliveCnt+'/'+POP_SIZE+'<br>' +
    'BEST '+Math.round(bestFit)+' pts<br>' +
    'RECORD '+Math.round(this.bestEver)+' pts';
};

var sims = [], frameCount = 0, simSpeed = 1, animId;

function updateSpeed(v) {
  simSpeed = parseInt(v);
  document.getElementById('spd').textContent  = simSpeed+'x';
  document.getElementById('spd2').textContent = simSpeed+'x';
}

function initAll() {
  sims = [];
  for (var i = 0; i < NUM_SIMS; i++) {
    var s = new Simulation(i); s.init(); sims.push(s);
  }
}

function simLoop() {
  animId = requestAnimationFrame(simLoop);
  frameCount++;
  var stepsThisFrame = (simSpeed <= 1) ? (frameCount % 2 === 0 ? 1 : 0) : simSpeed;
  for (var t = 0; t < stepsThisFrame; t++) {
    for (var i = 0; i < sims.length; i++) sims[i].update();
  }
  for (var j = 0; j < sims.length; j++) sims[j].draw();
}

function resetAll() {
  cancelAnimationFrame(animId);
  document.getElementById('speedSlider').value = 1;
  updateSpeed(1);
  initAll(); simLoop();
}

window.addEventListener('resize', function() { for (var i=0;i<sims.length;i++) sims[i].resize(); });
window.addEventListener('keydown', function(e) { if (e.code==='KeyR') resetAll(); });
window.addEventListener('load', function() {
  try {
    if (typeof neataptic === 'undefined') throw new Error('neataptic not loaded');
    initAll(); simLoop();
  } catch(e) {
    document.body.innerHTML += '<div style="color:#f44;padding:20px">Error: '+e.message+'</div>';
    console.error(e);
  }
});
</script>
</body>
</html>
